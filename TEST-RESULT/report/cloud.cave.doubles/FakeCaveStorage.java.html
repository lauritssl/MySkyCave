<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>FakeCaveStorage.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=2;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Coverage of SkyCave</a> &gt; <a href="index.source.html" class="el_package">cloud.cave.doubles</a> &gt; <span class="el_source">FakeCaveStorage.java</span></div><h1>FakeCaveStorage.java</h1><pre class="source lang-java linenums">package cloud.cave.doubles;

import java.util.*;

import cloud.cave.domain.*;
import cloud.cave.server.common.*;
import cloud.cave.service.*;

/**
 * Fake object implementation of storage. Map data structures are used to
 * simulate SQL tables or NoSQL collections. The used data structures are not
 * synchronized.
 * &lt;p&gt;
 * The cave is initialized with five rooms in a fixed layout, vaguely inspired
 * by the original Colossal Cave layout. These rooms serve the test cases.
 * 
 * @author Henrik Baerbak Christensen, Aarhus University.
 * 
 */
<span class="fc" id="L20">public class FakeCaveStorage implements CaveStorage {</span>
  
  // The table/collection of rooms in the cave.
  // The positionString is the primary key and the value object
  // for a room the rest of the tuple
  Map&lt;String,RoomRecord&gt; roomMap;

  @Override
  public void initialize(ServerConfiguration config) {
<span class="fc" id="L29">    this.serverConfiguration = config;</span>
<span class="fc" id="L30">    roomMap = new HashMap&lt;String, RoomRecord&gt;();</span>
<span class="fc" id="L31">    playerId2PlayerSpecs = new HashMap&lt;String, PlayerRecord&gt;(5);</span>

<span class="fc" id="L33">    RoomRecord entryRoom = new RoomRecord(</span>
        &quot;You are standing at the end of a road before a small brick building.&quot;);
<span class="fc" id="L35">    this.addRoom(new Point3(0, 0, 0).getPositionString(), entryRoom);</span>
<span class="fc" id="L36">    this.addRoom(new Point3(0, 1, 0).getPositionString(), new RoomRecord(</span>
        &quot;You are in open forest, with a deep valley to one side.&quot;));
<span class="fc" id="L38">    this.addRoom(new Point3(1, 0, 0).getPositionString(), new RoomRecord(</span>
        &quot;You are inside a building, a well house for a large spring.&quot;));
<span class="fc" id="L40">    this.addRoom(new Point3(-1, 0, 0).getPositionString(), new RoomRecord(</span>
        &quot;You have walked up a hill, still in the forest.&quot;));
<span class="fc" id="L42">    this.addRoom(new Point3(0, 0, 1).getPositionString(), new RoomRecord(</span>
        &quot;You are in the top of a tall tree, at the end of a road.&quot;));
<span class="fc" id="L44">  }</span>
  
  @Override
  public void disconnect() {
<span class="fc" id="L48">    roomMap = null;</span>
<span class="fc" id="L49">  }</span>

  @Override
  public RoomRecord getRoom(String positionString) {
<span class="fc" id="L53">    return roomMap.get(positionString);</span>
  }

  @Override
  public boolean addRoom(String positionString, RoomRecord newRoom) {
    // if there is already a room, return false
<span class="fc bfc" id="L59" title="All 4 branches covered.">    if ( roomMap.containsKey(positionString) ) { return false; }</span>
<span class="fc" id="L60">    roomMap.put(positionString, newRoom);</span>
<span class="fc" id="L61">    return true;</span>
  }

  @Override
  public List&lt;Direction&gt; getSetOfExitsFromRoom(String positionString) {
<span class="fc" id="L66">    List&lt;Direction&gt; listOfExits = new ArrayList&lt;Direction&gt;();</span>
<span class="fc" id="L67">    Point3 pZero = Point3.parseString(positionString);</span>
    Point3 p;
<span class="fc bfc" id="L69" title="All 4 branches covered.">    for ( Direction d : Direction.values()) {</span>
<span class="fc" id="L70">      p = new Point3(pZero.x(), pZero.y(), pZero.z());</span>
<span class="fc" id="L71">      p.translate(d);</span>
<span class="fc" id="L72">      String position = p.getPositionString();</span>
<span class="fc bfc" id="L73" title="All 4 branches covered.">      if ( roomMap.containsKey(position)) {</span>
<span class="fc" id="L74">        listOfExits.add(d);</span>
      }
    }
<span class="fc" id="L77">    return listOfExits;</span>
  }

  // === The table with primary key playerID whose columns are the
  // specifications of a given player. The private datastructure PlayerSpecs
  // represents the
  // remaining tuple values.
  
  Map&lt;String,PlayerRecord&gt; playerId2PlayerSpecs;

  @Override
  public PlayerRecord getPlayerByID(String playerID) {
<span class="fc" id="L89">    PlayerRecord ps = playerId2PlayerSpecs.get(playerID);</span>
<span class="fc" id="L90">    return ps;</span>
  }
  
  @Override
  public void updatePlayerRecord(PlayerRecord record) {
<span class="fc" id="L95">    playerId2PlayerSpecs.put(record.getPlayerID(), record);</span>
<span class="fc" id="L96">  }</span>

  @Override
  public List&lt;PlayerRecord&gt; computeListOfPlayersAt(String positionString) {
<span class="fc" id="L100">    List&lt;PlayerRecord&gt; theList = new ArrayList&lt;PlayerRecord&gt;();</span>
<span class="fc bfc" id="L101" title="All 4 branches covered.">    for ( String id : playerId2PlayerSpecs.keySet() ) {</span>
<span class="fc" id="L102">      PlayerRecord ps = playerId2PlayerSpecs.get(id);</span>
<span class="fc bfc" id="L103" title="All 8 branches covered.">      if (ps.isInCave() &amp;&amp; ps.getPositionAsString().equals(positionString)) {</span>
<span class="fc" id="L104">        theList.add(ps);</span>
      }
<span class="fc" id="L106">    }</span>
<span class="fc" id="L107">    return theList;</span>
  }
  
  @Override
  public int computeCountOfActivePlayers() {
<span class="fc" id="L112">    return getPlayerList().size();</span>
  }

  /** Compute the list of players in the cave.
   * 
   * @return list of all players in the cave.
   */
  private List&lt;PlayerRecord&gt; getPlayerList() {
<span class="fc" id="L120">    List&lt;PlayerRecord&gt; theList = </span>
        new ArrayList&lt;PlayerRecord&gt;();
<span class="fc bfc" id="L122" title="All 4 branches covered.">    for ( String id : playerId2PlayerSpecs.keySet() ) {</span>
<span class="fc" id="L123">      PlayerRecord ps = playerId2PlayerSpecs.get(id);</span>
<span class="fc bfc" id="L124" title="All 4 branches covered.">      if (ps.isInCave()) {</span>
<span class="fc" id="L125">        theList.add(ps);</span>
      }
<span class="fc" id="L127">    }</span>
<span class="fc" id="L128">    return theList;</span>
  }

  /**
   * Debugging method to dump contents of internal data structures
   * 
   * @return the contents of the map(player id, player records)
   */
  public String dumpContents() {
<span class="nc" id="L137">    return &quot;FakeStorage: &quot;+playerId2PlayerSpecs+&quot;.&quot;;</span>
  }

  public String toString() {
<span class="fc" id="L141">    return &quot;FakeCaveStorage (Fake Object implementation of in-memory storage)&quot;;</span>
  }

  ServerConfiguration serverConfiguration;
  
  @Override
  public ServerConfiguration getConfiguration() {
<span class="fc" id="L148">    return serverConfiguration;</span>
  }
  
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.6.201506030918</span></div></body></html>