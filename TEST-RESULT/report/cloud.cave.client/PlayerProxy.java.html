<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>PlayerProxy.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=2;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Coverage of SkyCave</a> &gt; <a href="index.source.html" class="el_package">cloud.cave.client</a> &gt; <span class="el_source">PlayerProxy.java</span></div><h1>PlayerProxy.java</h1><pre class="source lang-java linenums">package cloud.cave.client;

import java.util.*;

import org.json.simple.*;

import cloud.cave.common.PlayerSessionExpiredException;
import cloud.cave.domain.*;
import cloud.cave.ipc.*;

/**
 * A Proxy (Flexible, Reliable Software, p. 317) or more specifically a
 * Client Proxy (Patterns-oriented Software Architecture, Vol 4, p. 240) for
 * the Player role. 
 * &lt;p&gt;
 * Never instantiate a player proxy instance directly, instead you must
 * create a cave proxy, and use its login method to retrieve the player
 * proxy. 
 * &lt;p&gt;
 * All methods follow the same remote proxy template
 * &lt;ol&gt;
 * &lt;li&gt; Marshal this and parameters into a request object in JSON
 * &lt;li&gt; Send it to server and await reply
 * &lt;li&gt; Convert reply object back into return values
 * &lt;/ol&gt;
 * It may also become a Half-Object Plus Protocol (Patterns-oriented Software
 * Architecture, Vol 4, p. 324). 
 * &lt;p&gt;
 * 
 * @author Henrik Baerbak Christensen, Aarhus University
 * 
 */
public class PlayerProxy implements Player {
  private ClientRequestHandler crh;

  private String playerID;
  private String playerName;
  private String sessionID;
  
  private JSONObject requestJson;

  /**
   * DO NOT USE THIS CONSTRUCTOR DIRECTLY (except in unit tests perhaps). Create
   * the player proxy configured with the relevant request handler and
   * properties.
   * 
   * @param crh
   *          the client request handler to communicate with the server based
   *          player instance
   * @param playerID
   *          id of the player
   * @param playerName
   *          name of the player
   * @param sessionID
   *          id of the session initiated by this player's login
   */
  PlayerProxy(ClientRequestHandler crh, 
<span class="fc" id="L58">      String playerID, String playerName, String sessionID) {</span>
<span class="fc" id="L59">    this.playerID = playerID;</span>
<span class="fc" id="L60">    this.playerName = playerName;</span>
<span class="fc" id="L61">    this.sessionID = sessionID;</span>
<span class="fc" id="L62">    this.crh = crh;</span>
<span class="fc" id="L63">  }</span>

  @Override
  public String getID() {
<span class="fc" id="L67">    return playerID;</span>
  }

  @Override
  public String getShortRoomDescription() {
    // Build the request object
<span class="fc" id="L73">    requestJson = createRequestObject(MarshalingKeys.GET_SHORT_ROOM_DESCRIPTION_METHOD_KEY, &quot;&quot;);</span>
    // send the request over the connector and retrieve the reply object 
<span class="fc" id="L75">    JSONObject replyJson = requestAndAwaitReply(requestJson);</span>
    // and finally, demarshal the returned value
<span class="fc" id="L77">    String asString = replyJson.get(MarshalingKeys.RETURNVALUE_HEAD_KEY).toString(); </span>
<span class="fc" id="L78">    return asString;</span>
  }

  @Override
  public String getLongRoomDescription() {
<span class="fc" id="L83">    requestJson = createRequestObject(MarshalingKeys.GET_LONG_ROOM_DESCRIPTION_METHOD_KEY, &quot;&quot;);</span>
<span class="fc" id="L84">    JSONObject replyJson = requestAndAwaitReply(requestJson); </span>
<span class="fc" id="L85">    String asString = replyJson.get(MarshalingKeys.RETURNVALUE_HEAD_KEY).toString(); </span>
<span class="fc" id="L86">    return asString;</span>
  }

  @Override
  public String getName() {
<span class="fc" id="L91">    return playerName;</span>
  }

  @Override
  public String getSessionID() {
<span class="fc" id="L96">    return sessionID;</span>
  }

  @Override
  public Region getRegion() {
<span class="fc" id="L101">    requestJson = createRequestObject(MarshalingKeys.GET_REGION_METHOD_KEY, </span>
        &quot;&quot;); 
<span class="fc" id="L103">    JSONObject replyJson = requestAndAwaitReply(requestJson); </span>
<span class="fc" id="L104">    String asString = replyJson.get(MarshalingKeys.RETURNVALUE_HEAD_KEY).toString(); </span>
<span class="fc" id="L105">    Region unboxed = Region.valueOf(asString); </span>
<span class="fc" id="L106">    return unboxed; </span>
  }

  @Override
  public boolean move(Direction direction) {
<span class="fc" id="L111">    requestJson = createRequestObject(MarshalingKeys.MOVE_METHOD_KEY, </span>
<span class="fc" id="L112">            direction.toString()); </span>
<span class="fc" id="L113">    JSONObject replyJson = requestAndAwaitReply(requestJson); </span>
<span class="fc" id="L114">    String asString = replyJson.get(MarshalingKeys.RETURNVALUE_HEAD_KEY).toString(); </span>
<span class="fc" id="L115">    boolean unboxed = Boolean.parseBoolean(asString); </span>
<span class="fc" id="L116">    return unboxed; </span>
  }

  @Override
  public boolean digRoom(Direction direction, String description) {
<span class="fc" id="L121">    JSONObject requestJson = </span>
<span class="fc" id="L122">        Marshaling.createRequestObject(playerID, </span>
            sessionID, MarshalingKeys.DIG_ROOM_METHOD_KEY, 
<span class="fc" id="L124">            &quot;&quot;+direction.toString(), description);</span>
<span class="fc" id="L125">    JSONObject replyJson = requestAndAwaitReply(requestJson); </span>
<span class="fc" id="L126">    String asString = replyJson.get(MarshalingKeys.RETURNVALUE_HEAD_KEY).toString(); </span>
<span class="fc" id="L127">    boolean unboxed = Boolean.parseBoolean(asString); </span>
<span class="fc" id="L128">    return unboxed;</span>
  }

  @Override
  public String getPosition() {
<span class="fc" id="L133">    requestJson = createRequestObject(MarshalingKeys.GET_POSITION_METHOD_KEY, null); </span>
<span class="fc" id="L134">    JSONObject replyJson = requestAndAwaitReply(requestJson); </span>
<span class="fc" id="L135">    String positionString = replyJson.get(MarshalingKeys.RETURNVALUE_HEAD_KEY).toString(); </span>
    
<span class="fc" id="L137">    return positionString;</span>
  }

  @Override
  public List&lt;Direction&gt; getExitSet() {
<span class="fc" id="L142">    requestJson = createRequestObject(MarshalingKeys.GET_EXITSET_METHOD_KEY, null); </span>
<span class="fc" id="L143">    JSONObject replyJson = requestAndAwaitReply(requestJson); </span>
    // The HEAD is not used, the list of player names are stored in the TAIL
<span class="fc" id="L145">    List&lt;Direction&gt; exitsHere = new ArrayList&lt;Direction&gt;();</span>
<span class="fc" id="L146">    JSONArray array = (JSONArray) replyJson.get(MarshalingKeys.RETURNVALUE_TAIL_KEY);</span>
    // Convert the string values back into enums
<span class="fc bfc" id="L148" title="All 4 branches covered.">    for ( Object item : array ) {</span>
<span class="fc" id="L149">      exitsHere.add(Direction.valueOf(item.toString()));</span>
<span class="fc" id="L150">    }</span>
<span class="fc" id="L151">    return exitsHere;</span>
  }

  @Override
  public List&lt;String&gt; getPlayersHere() {
<span class="fc" id="L156">    JSONObject requestJson = createRequestObject(MarshalingKeys.GET_PLAYERS_HERE_METHOD_KEY, &quot;&quot;);</span>
<span class="fc" id="L157">    JSONObject replyJson = requestAndAwaitReply(requestJson);</span>
    // The HEAD is not used, the list of player names are stored in the TAIL
<span class="fc" id="L159">    List&lt;String&gt; playersHere = new ArrayList&lt;String&gt;();</span>
<span class="fc" id="L160">    JSONArray array = (JSONArray) replyJson.get(MarshalingKeys.RETURNVALUE_TAIL_KEY);</span>
    // Convert it into a string list
<span class="fc bfc" id="L162" title="All 4 branches covered.">    for ( Object item : array ) {</span>
<span class="fc" id="L163">      playersHere.add(item.toString());</span>
<span class="fc" id="L164">    }</span>
<span class="fc" id="L165">    return playersHere;</span>
  }

  @Override
  public void addMessage(String message) {
    // TODO Empty stub, to be implemented by students
<span class="fc" id="L171">  }</span>

  @Override
  public List&lt;String&gt; getMessageList() {
    // TODO Empty stub, to be implemented by students
<span class="fc" id="L176">    List&lt;String&gt; contents = new ArrayList&lt;String&gt;();</span>
<span class="fc" id="L177">    contents.add(&quot;NOT IMPLEMENTED YET&quot;);</span>
<span class="fc" id="L178">    return contents;</span>
  }

  @Override
  public String getWeather() {
    // TODO Empty stub, to be implemented by students
<span class="fc" id="L184">    return &quot;NOT IMPLEMENTED YET&quot;;</span>
  }

  @Override
  public JSONObject execute(String commandName, String... parameters) {
<span class="fc" id="L189">    JSONObject requestJson = </span>
<span class="fc" id="L190">        Marshaling.createRequestObject(playerID, sessionID, MarshalingKeys.EXECUTE_METHOD_KEY, commandName, parameters);</span>
<span class="fc" id="L191">    JSONObject replyJson = requestAndAwaitReply(requestJson); </span>
<span class="fc" id="L192">    return replyJson;</span>
  }

  @Override
  public String toString() {
<span class="fc" id="L197">    return &quot;(PlayerClientProxy: &quot;+getID()+&quot;/&quot;+getName()+&quot;)&quot;;</span>
  }

  public JSONObject lastSentRequestObject() {
<span class="fc" id="L201">    return requestJson;</span>
  }

  private JSONObject createRequestObject(String methodKey,
      String parameter) {
<span class="fc" id="L206">    JSONObject requestJson = </span>
<span class="fc" id="L207">        Marshaling.createRequestObject(playerID, sessionID, methodKey, parameter);</span>
<span class="fc" id="L208">    return requestJson;</span>
  }

  private JSONObject requestAndAwaitReply(JSONObject requestJson) {
<span class="fc" id="L212">    JSONObject replyJson = ClientCommon.requestAndAwaitReply(crh, requestJson);</span>
<span class="fc" id="L213">    String statusCode = replyJson.get(MarshalingKeys.ERROR_CODE_KEY).toString();</span>
<span class="fc bfc" id="L214" title="All 4 branches covered.">    if ( statusCode.equals(StatusCode.SERVER_PLAYER_SESSION_EXPIRED_FAILURE) ) {</span>
<span class="fc" id="L215">      String errMsg = replyJson.get(MarshalingKeys.ERROR_MSG_KEY).toString();</span>
<span class="fc" id="L216">      throw new PlayerSessionExpiredException(errMsg);</span>
    }

<span class="fc" id="L219">    return replyJson;</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.6.201506030918</span></div></body></html>